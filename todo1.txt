
исправь нейминг для cpp и h файлов

void ViewSrc::setMaxTrackbar(cv::String name, int* trackbar) {
      cv::createTrackbar(name, winName, trackbar, 240);
}

//Функция cv::createTrackbar() создает новый трекбар.
//А нам надо старому трекбару просто изменить максимальное значение
//Для этого есть функция cv::setTrackbarMax(name, winName, max);
//Параметр max задаем аргументом в функции ViewSrc::setMaxTrackbar()
//И заодно задаем другое положение ползунка через функцию cv::setTrackbarPos(name, winName, pos);
//Параметр pos тоже задаем еще одним аргументом в функции ViewSrc::setMaxTrackbar()
//int* trackbar тут вообще не нужен

//Вызываем две функции setMaxTrackbar по кнопке hsv модели на два трекбара "par1" и "par2"
//max у нас будет 240, pos тебе надо будет подобрать
//Трекбар "par1" будет отвечать за hue(оттенок)
//Трекбар "par2" будет отвечать за saturation(контраст)
//value(яркость) не будем менять, зададим почти максимальный диапазон по яркости


//Основная наша функия будет вот эта. Она из hsv картинки сделает черно белую. И белым цветом оставит то,
//что попало между двумя двумя границами цвета cv::Scalar(hue_from, sat_from, val_from) и cv::Scalar(hue_to, sat_to, val_to)
cv::inRange(
      hsvImage,
      cv::Scalar(hue_from, sat_from, val_from),
      cv::Scalar(hue_to, sat_to, val_to),
    rangeImage
);

//Сами грацицы возьмем с трекбаров
hue_from = _par1 - 25;
hue_to = _par2 + 25;

//Предлагаю начать с диапазона в 50, потом можно им тоже поиграться.
//Не забудь сделать проверку чтобы hue_from не стал менбше нуля, а hue_to не стал больше 240
//Тоже самое все по sat_from и sat_to, бери из второго трекбара тоже с диапазоном 50
//А val_from предлагаю поставить в 30 и val_to в 220. Это почти весь дипазон по яркости
//Немного не берем только самые темные цвета и самые светлые

//на этом этапе надо подобрать нужные нам значения. Выводи rangeImage и смотри какие лучше срабатывают
//значения hue и sat можно в пейнте обычном взять. Делаешь принтскрин экрана с обьектом
//в пейнте определяешь его цвет и в палитре смотришь его значения

//чтобы убрать потенциальные дэрки между сегментами, следом вызываем специальную функцию
cv::Mat dilateImage;
cv::dilate(
    rangeImage,
    dilateImage,
    cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(25, 25))
);

//Она вокруг каждого пикселя расширяет цвет на круг размером cv::Size(25, 25)
//Ну значения 25 тоже поэкспереинтируй какие получше будут в твоем случае.
//Можешь даже третий трекбар завести для этого параметра
//на этом этапе выводи на экран dilateImage для проверки

//и наконец выделяем контура
cv::findContours(dilateImage, contours, cv::RETR_LIST, cv::CHAIN_APPROX_SIMPLE);
//эта функция контура сохраняет в вектор contours. Она не рисует их
//посмотри как эти контуры прорисовать. Я контура рисовал на изначальное rgb изображение
//еще можно побаловаться с функцией
cv::approxPolyDP(contours[i], approx, 10, true);
//она апроксимирует контура с определенной точностью. У менят тут 10. Они получаются не такими изрезанными
//окружающий прямоугольник можно так вот сделать
auto rect = cv::boundingRect(contours[i]);
//и так я его отрисовал, тут cv::Scalar(0, 255, 0) это rgb цвет. Тут чисто зеленый
cv::rectangle(resImage, rect, cv::Scalar(0, 255, 0));

 

